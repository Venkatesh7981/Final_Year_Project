#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32MultiArray
import cv2
import mediapipe as mp
from collections import deque

mp_hands = mp.solutions.hands
mp_drawing = mp.solutions.drawing_utils


class FingerAnglePublisher(Node):
    def __init__(self):
        super().__init__('gesture_angle_publisher')

        self.publisher_ = self.create_publisher(
            Float32MultiArray, '/detected_angles', 10
        )

        # ---------------- CAMERA ----------------
        self.cap = cv2.VideoCapture(0)
        if not self.cap.isOpened():
            self.get_logger().error("Webcam not accessible.")
            exit(1)

        self.hands = mp_hands.Hands(
            max_num_hands=1,
            min_detection_confidence=0.7,
            min_tracking_confidence=0.7
        )

        # ---------------- SMOOTHING ----------------
        self.hist_base = deque(maxlen=15)
        self.hist_shoulder = deque(maxlen=15)
        self.hist_elbow = deque(maxlen=15)
        self.hist_wrist = deque(maxlen=15)

        # ---------------- JOINTS ----------------
        self.base = 0.0
        self.shoulder = 0.0
        self.elbow = 0.0
        self.wrist = 0.0

        # ---------------- SPEED & ACCURACY CONTROL ----------------
        self.SPEED_SCALE = 0.05      # VERY SLOW
        self.DEAD_ZONE = 2.0         # degrees (ignore small motion)

        # ---------------- SUCTION CUP ----------------
        self.suction = 0.0

        self.timer = self.create_timer(0.1, self.detect_and_publish)
        self.get_logger().info("Gesture Controller (LOW accuracy, VERY slow)")

    # =====================================================
    def detect_and_publish(self):
        ret, frame = self.cap.read()
        if not ret:
            return

        frame = cv2.flip(frame, 1)
        h, w, _ = frame.shape
        cx, cy = w // 2, h // 2

        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        result = self.hands.process(rgb)

        mode = "IDLE"

        if result.multi_hand_landmarks:
            hand = result.multi_hand_landmarks[0]
            lm = hand.landmark

            tips = [8, 12, 16, 20]
            pips = [6, 10, 14, 18]

            fingers_up = sum(lm[t].y < lm[p].y for t, p in zip(tips, pips))
            thumb_up = lm[4].y < lm[3].y

            index_x = lm[8].x * w
            index_y = lm[8].y * h
            middle_y = lm[12].y * h

            # -------- ARM CONTROL --------
            if fingers_up == 1:
                mode = "BASE"
                raw = self.map_x(index_x, cx, 180)
                self.base = self.update_joint(raw, self.hist_base)

            elif fingers_up == 2:
                mode = "SHOULDER"
                raw = self.map_y(index_y, cy, 90)
                self.shoulder = self.update_joint(raw, self.hist_shoulder)

            elif fingers_up == 3:
                mode = "ELBOW"
                raw = self.map_y(middle_y, cy, 90)
                self.elbow = self.update_joint(raw, self.hist_elbow)

            elif fingers_up == 4:
                mode = "WRIST"
                raw = self.map_x(index_x, cx, 90)
                self.wrist = self.update_joint(raw, self.hist_wrist)

            elif fingers_up == 5:
                mode = "HOME + SUCTION OFF"
                self.base = self.shoulder = self.elbow = self.wrist = 0.0
                self.suction = 0.0

            # -------- SUCTION CONTROL --------
            if thumb_up and fingers_up == 0:
                mode = "SUCTION ON"
                self.suction = 1.0

            mp_drawing.draw_landmarks(frame, hand, mp_hands.HAND_CONNECTIONS)

        # -------- PUBLISH --------
        msg = Float32MultiArray()
        msg.data = [
            self.base,
            self.shoulder,
            self.elbow,
            self.wrist,
            self.suction
        ]
        self.publisher_.publish(msg)

        cv2.putText(frame, f"Mode: {mode}", (20, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)

        cv2.imshow("Gesture Control (Low Accuracy / Very Slow)", frame)
        if cv2.waitKey(1) & 0xFF == ord('q'):
            rclpy.shutdown()

    # =====================================================
    def update_joint(self, raw_angle, history):
        # Apply speed scaling
        scaled = raw_angle * self.SPEED_SCALE

        # Dead zone (reduce accuracy)
        if abs(scaled) < self.DEAD_ZONE:
            scaled = 0.0

        # Smooth strongly
        return self.smooth(scaled, history)

    def map_x(self, x, center, max_angle):
        delta = x - center
        return clamp((delta / center) * (max_angle / 2),
                     -max_angle / 2, max_angle / 2)

    def map_y(self, y, center, max_angle):
        delta = center - y
        return clamp((delta / center) * max_angle,
                     -max_angle, max_angle)

    def smooth(self, new, history, alpha=0.05):
        if not history:
            history.append(new)
        else:
            history.append(alpha * new + (1 - alpha) * history[-1])
        return history[-1]

    def on_shutdown(self):
        self.cap.release()
        cv2.destroyAllWindows()


def clamp(val, mn, mx):
    return max(mn, min(mx, val))


def main(args=None):
    rclpy.init(args=args)
    node = FingerAnglePublisher()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.on_shutdown()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
